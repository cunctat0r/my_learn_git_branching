# Теряем голову, или detached HEAD

`HEAD` - это символическое имя текущего выбранного коммита — это, по сути, тот коммит, над которым мы в данным момент работаем.

`HEAD` всегда указывает на последний коммит из вашего локального дерева. Большинство команд Git, изменяющих рабочее дерево, начнут с изменения `HEAD`.

Отделим `HEAD` от ветки `bugFix` и присвоим его последнему коммиту в этой же ветке.

Укажи коммит при помощи его идентификатора (hash).

    ```
    $ git checkout C4
    ```

# Относительные ссылки (^)

С относительными ссылками можно начать с какого-либо удобного места (например, с ветки `bugFix` или от `HEAD`) и двигаться от него.

Относительные ссылки - мощный инструмент, но мы покажем два простых способа использования:

  - Перемещение на один коммит назад `^`
  - Перемещение на `<num>` коммитов назад `~<num>`

`master^` означает "первый предок ветки `master`".
`master^^` означает предок предка ветки `master`

Чтобы пройти этот уровень, переместись на первого родителя ветки `bugFix`. Это отделит `HEAD` от ветки.

    ```
    $ git checkout bugFix
    $ git checkout HEAD^
    ```

# Относительные ссылки №2

Предположим, нужно переместиться на много шагов назад по дереву. Было бы неудобно печатать `^` несколько раз (или несколько десятков раз), так что Git поддерживает также оператор тильда (`~`).

К тильде (опционально) можно добавить количество родительских коммитов, через которые нужно пройти.

Одна из наиболее распространённых целей, для которых используются относительные ссылки - это перемещение веток. Можно напрямую прикрепить ветку к коммиту при помощи опции `-f`. Например, команда:

    ```
    git branch -f master HEAD~3
    ```

Переместит (принудительно) ветку master на три родителя назад от `HEAD`.

Чтобы пройти этот уровень, передвинь `HEAD`, `master` и `bugFix` так, как показано на визуализации.

    ```
    $ git checkout C6
    $ git branch -f master HEAD
    $ git checkout HEAD~3
    $ git branch -f bugFix
    ```

# Отмена изменений в Git

Так же как и коммит, отмена изменений в Git возможна и на низком уровне (добавление в коммит отдельных файлов и наборов строк), и на высоком (как изменения реально отменяются). Сейчас сфокусируемся на высокоуровневой части.

Есть два основных способа отмены изменений в Git: первый - это `git reset`, а второй - `git revert`

`git reset` отменяет изменения, перенося ссылку на ветку назад, на более старый коммит. Это своего рода "переписывание истории"; `git reset` перенесёт ветку назад, как будто некоторых коммитов вовсе и не было.

Reset отлично работает на локальных ветках, в локальных репозиториях. Но этот метод переписывания истории не сработает на удалённых ветках, которые используют другие пользователи.

Чтобы отменить изменения и поделиться отменёнными изменениями с остальными, надо использовать `git revert`. 

После `git revert HEAD` появился новый коммит. Дело в том, что новый коммит `C2'` просто содержит изменения, полностью противоположные тем, что сделаны в коммите `C2`.

После `revert` можно сделать `push` и поделиться изменениями с остальными.

Чтобы пройти этот уровень, отмени два последних коммита и в `local`, и в `pushed`.

Помни, что pushed - это remote ветка, а local - это локальная ветка. Это поможет выбрать способ отмены изменений.

    ```
    $ git reset HEAD^
    $ git checkout pushed
    $ git revert HEAD
    ```

